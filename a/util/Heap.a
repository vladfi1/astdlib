package a.util;

/**
 * Manages the Heap, which can dynamically allocate arrays.
 * Uses a buddy system to minimize internal fragmentation.
 * @author XPilot
 */
public static class Heap {

	/**
	 * Signifies an allocation error.
	 */
	public static const int ERROR = -1;
	
	/**
	 * The number of levels used in this Heap.
	 */
	public static const int LEVEL = 14;
	
	/**
	 * Size of the backing array. Has the value 2^LEVEL.
	 */
	public static const int HEAP_SIZE = 1 << LEVEL;
	
	private static const int SIZE = HEAP_SIZE + 2 * LEVEL;
	/**
	 * The backing array. The last 2*LEVEL indexes are for header information.
	 */
	public static int[SIZE] array;

	private static const int LISTS = LEVEL + 1;
	/**
	 * Each list keeps track of the nodes at a certain level.
	 */
	private static BlockList[LISTS] lists;
	
	/*
	static {
		initHeap();
	}
	*/
	
	/**
	 * Initializes the Heap. Should be done in the static init block.
	 */
	public static void initHeap() {
		for(int i = 1; i <= LEVEL; i++) {
			lists[i] = new BlockList(i);
		}
		lists[LEVEL].add(0);
	}
	
	//methods for manipulating the block headers
	private static const int LEVEL_BITS = 5;
	private static const int LEVEL_MASK = (1 << LEVEL_BITS) - 1;
	private static const int OTHER_BITS = 32 - LEVEL_BITS;
	private static const int OTHER_MASK = (1 << OTHER_BITS) - 1;
	
	static int level(int index) {
		return (array[index] >> OTHER_BITS) & LEVEL_MASK;
	}
	
	static int prev(int index) {
		return array[index] & OTHER_MASK;
	}
	
	static int next(int index) {
		return array[index + 1];
	}
	
	static void setHeader(int index, int level, int prev, int next) {
		array[index] = (level << OTHER_BITS) | prev;
		array[index + 1] = next;
	}
	
	static void setPrev(int index, int prev) {
		array[index] = (array[index] & ~OTHER_MASK) | prev;
	}
	
	static void setNext(int index, int next) {
		array[index + 1] = next;
	}

	/**
	 * Switches the level'th bit of index.
	 */
	//static int buddy(int level, int index) {return index ^ (1 << level);}
	private static int buddy(int level, int index) {
		if((index & (1 << level)) == 0) return index | (1 << level);
		else return index & ~(1 << level);
	}
	
	/**
	 * The minimum level at which size can be stored.
	 * @return 1 + log_2(size) rounded down.
	 */
	public static int minLevel(int size) {
		int level = 1;
		while(size != 1) {
			size = size >> 1;
			level++;
		}
		return level;
	}
	
	/**
	 * The maximum size that can be stored at a level.
	 * @return (2 ^ level) - 1
	 */
	public static int maxSize(int level) {
		return (1 << level) - 1;
	}
	
	/**
	 * Rounds up to the next level.
	 * @return maxSize(minLevel(size))
	 */
	public static int round(int size) {
		return maxSize(minLevel(size));
	}

	/**
	 * Attempts to allocate a block of the specified size.
	 * @return The index of the block, or ERROR = -1 if unsuccessful.
	 */
	public static int alloc(int size) {
		if(size <= 0) return ERROR;
		
		//the minimum level needed to hold this size
		int level = minLevel(size);

		//finds the next free block large enough
		int i = level;
		while(i <= LEVEL && lists[i].isEmpty()) i++;
		
		//no block found
		if(i > LEVEL) {
			System.error("Could not allocate memory in Heap.");
			return ERROR;
		}
		
		//starts splitting blocks until until one of the right level is created
		int index = lists[i].remove();
		while(i > level) {
			i--;
			int right = buddy(i, index);
			lists[i].add(right);
		}
		//marks the block as taken (upper LEVEL_BITS bits are 0) and stores level
		array[index] = level;
		
		//returns the index
		return index + 1;
	}
	
	/**
	 * Deallocates a block.
	 * @param index The index of the block.
	 */
	public static void dealloc(int index) {
		index--;
		int level = array[index];
		
		//attempts to merge as many free blocks as possible
		while(level < LEVEL) {
			//this block's buddy
			int buddy = buddy(level, index);
			
			//tests if the buddy is free and is of the same level
			if(level(buddy) == level) {
				lists[level].remove(buddy);
				//merges blocks
				if(buddy < index) index = buddy;
				level++;
			} else break;
		}
		
		//adds the free block to the appropriate list
		lists[level].add(index);
	}
	
	/**
	 * Tries to reallocate the given data to block of the given size.
	 * @return Same as alloc(size). ERROR if unsuccessful.
	 * If unsuccessful, the original data will remain unchanged.
	 */
	public static int realloc(int index, int size) {
		int index2 = alloc(size);
		if(index2 != ERROR) {
			int min = maxSize(array[index - 1]);
			if(size < min) min = size;
			for(int i = 0; i < min; i++) {
				array[index2 + i] = array[index + i];
			}
			dealloc(index);
		}
		return index2;
	}
	
	/**
	 * Prints Heap statistics to debug.
	 */
	public static void stats() {
		int free_bytes = 0, free_blocks = 0;
		
		for(int i = 1; i <= LEVEL; i++) {
			free_bytes += lists[i].size * (1 << i);
			free_blocks += lists[i].size;
			System.debug("Level " + i + ": " + lists[i].size + " free blocks.");
			lists[i].debug();
		}
		
		System.debug(IntToString(free_blocks) + " free blocks, " + free_bytes + "/" + HEAP_SIZE + " free bytes.");
	}
}

/**
 * Keeps track of the free blocks of a certain level.
 */
private class BlockList [Heap.LEVEL] {
	//the level of the blocks in this list
	int level;
	//the head index of the doubly linked list
	int head;
	//current size of the list
	int size;
	
	BlockList(int level) {
		this.level = level;
		head = Heap.HEAP_SIZE + 2 * (level - 1);
		Heap.setHeader(head, level, head, head);
		size = 0;
	}
	
	bool isEmpty() {
		return size == 0;
	}
	
	/**
	 * Adds a block to the front of the list.
	 * Sets headers as appropriate.
	 */
	void add(int index) {
		int next = Heap.next(head);
		Heap.setNext(head, index);
		Heap.setPrev(next, index);
		Heap.setHeader(index, level, head, next);
		size++;
	}
	
	/**
	 * Removes a block from the end of the list.
	 * Calls remove(prev), where prev is the index of the last block in this list.
	 * @return prev
	 */
	int remove() {
		int prev = Heap.prev(head);
		remove(prev);
		return prev;
	}
	
	/**
	 * Removes an arbitrary block from the list.
	 * Sets headers as appropriate.
	 * Used when merging blocks.
	 */
	void remove(int index) {
		int prev = Heap.prev(index);
		int next = Heap.next(index);
		
		Heap.setNext(prev, next);
		Heap.setPrev(next, prev);
		size--;
	}
	
	void debug() {
		for(int next = Heap.next(head); next != head; next = Heap.next(next)) {
			System.debug(IntToString(next));
		}
	}
}
