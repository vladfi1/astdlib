package a.util;

import a.util.Heap;
import a.util.HeapUtil;

/**
 * ArrayList implementation that uses the Heap as storage.
 * @author XPilot
 */
public class ArrayList<E> [256] {
	
	public static const int DEFAULT_CAPACITY = 7;

	/**
	 * The ArrayList's capacity.
	 */
	private int capacity;
	/**
	 * The index in the Heap.
	 */
	private int index;
	/**
	 * The current size.
	 */
	private int size;
	
	/**
	 * ArrayList with capacity DEFAULT_CAPACITY.
	 */
	public ArrayList() {
		this(DEFAULT_CAPACITY);
	}

	/**
	 * ArrayList with specified capacity.
	 * @param capacity Must be positive.
	 */
	public ArrayList(int capacity) {
		index = Heap.alloc(capacity);
		this.capacity = Heap.round(capacity);
		size = 0;
	}
	
	~ArrayList() {
		Heap.dealloc(index);
	}
	
	/**
	 * @return The number of elements in this ArrayList.
	 */
	public int size() {
		return size;
	}
	
	/**
	 * @return Whether this ArrayList is empty.
	 */
	public bool isEmpty() {
		return size == 0;
	}
	
	/**
	 * Clears this ArrayList.
	 * Does not delete the elements.
	 */
	public void clear() {
		size = 0;
	}
	
	/**
	 * Deletes all elements.
	 */
	public void deleteAll() {
		for(int i = 0; i < size; i++)
			delete getIndex(i);
		size = 0;
	}
	
	/**
	 * @return A shallow copy of this ArrayList.
	 */
	public ArrayList<E> clone() {
		ArrayList<E> clone = new ArrayList<E>(capacity);
		HeapUtil.copy(index, clone.index, size);
		clone.size = size;
		return clone;
	}
	
	/**
	 * Tries to set the capacity to a specified amount.
	 * @return Whether successful.
	 */
	public bool setCapacity(int capacity) {
		int index = Heap.realloc(index, capacity);
		if(index == Heap.ERROR) return false;
		this.index = index;
		this.capacity = Heap.round(capacity);
		return true;
	}
	
	/**
	 * Ensures a minimum specified capacity.
	 * @return Whether successful.
	 */
	public bool ensureCapacity(int capacity) {
		if(capacity < this.capacity) return true;
		return setCapacity(capacity);
	}
	
	/**
	 * Decreases the capacity to a certain level.
	 * @return Whether successful.
	 */
	public bool decreaseCapacity(int capacity) {
		if(capacity < size) return false;
		return setCapacity(capacity);
	}
	
	/**
	 * Decreases the capacity to its minimum possible level.
	 * @return Whether successful.
	 */
	public bool trimToSize() {
		return decreaseCapacity(size);
	}
	
	/**
	 * @return The element at index.
	 */
	public E getIndex(int index) {
		if(index < 0 || index >= size) return null;
		return (E)Heap.array[this.index + index];
	}
	
	/**
	 * Sets the element at index.
	 * @return Whether successful.
	 */
	public bool setIndex(int index, E element) {
		if(index < 0 || index >= size) return false;
		Heap.array[this.index + index] = element;
		return true;
	}
	
	/**
	 * Adds an element to the end of this list.
	 * @return Whether successful.
	 */
	public bool addLast(E element) {
		if(size == capacity)
			if(!ensureCapacity(size + 1)) return false;
		
		Heap.array[this.index + size] = element;
		size++;
		return true;
	}
	
	/**
	 * Adds an element at index.
	 * @return Whether successful.
	 */
	public bool addIndex(int index, E element) {
		if(index < 0 || index > size) return false;
		if(size == capacity)
			if(!ensureCapacity(size + 1)) return false;
		
		HeapUtil.copy(index, index + 1, size - index);
		Heap.array[this.index + index] = element;
		size++;
		return true;
	}
	
	/**
	 * Removes the last element of this list.
	 * @return The element removed.
	 */
	public E removeLast() {
		if(isEmpty()) return null;
		size--;
		E element = Heap.array[this.index + size];
		return element;
	}
	
	/**
	 * Removes the element at index.
	 * @return The element removed.
	 */
	public E removeIndex(int index) {
		if(index < 0 || index > size) return null;
		E element = Heap.array[this.index + index];
		HeapUtil.copy(index + 1, index, size - index - 1);
		size--;
		return element;
	}
	
	/**
	 * @return An iterator for this ArrayList.
	 */
	public ArrayListIterator<E> getIterator() {
		return new ArrayIterator(this);
	}
	
	public Array<E> toArray() {
		Array<E> array = new Array<E>(size);
		HeapUtil.copy(index, array.index, size);
		return array;
	}

	/**
	 * @return Whether this ArrayList contains element.
	 */
	public bool contains(E element) {
		for(int i = 0; i < size; i++) {
			if(getIndex(i) == element) return true;
		}
		return false;
	}
	
	/**
	 * Sorts this ArrayList in ascending order.
	 */
	public void sort(Comparator<E> comparator) {
		HeapSort.heapSort(index, size, comparator);
	}
	
	/**
	 * Searches for element assuming that the list is in ascending order.
	 * @return The index of the element, or -1 if not found.
	 */
	public int binarySearch(E element, Comparator<E> comparator) {
		return HeapUtil.binarySearch(index, size, element, comparator);
	}
}

/**
 * Iterator for ArrayList.
 */
private class ArrayListIterator<E> [64] {
	private ArrayList<E> list;
	private int index;
	
	ArrayListIterator(ArrayList<E> list) {
		this.list = list;
		index = 0;
	}
	
	public bool hasNext() {return index < list.size();}
	
	public E next() {
		E temp = list.getIndex(index);
		index++;
		return temp;
	}
}
