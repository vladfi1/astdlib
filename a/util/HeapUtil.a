package a.util;

import a.util.Heap;
import a.util.Comparator;

/**
 * Useful functions for the Heap. They are very unsafe, as they can
 * easily corrupt the Heap, and are primarily for use by libraries.
 */
public static class HeapUtil {

	public static void swap(int ptr1, int ptr2) {
		int temp = Heap.array[ptr1];
		Heap.array[ptr1] = Heap.array[ptr2];
		Heap.array[ptr2] = temp;
	}

	public static void copy(int src, int dest, int len) {
		if(dest > src && dest - src < len) {
			for(int i = len - 1; i >= 0; i--) {
				Heap.array[dest + i] = Heap.array[src + i];
			}
		} else {
			for(int i = 0; i < len; i++) {
				Heap.array[dest + i] = Heap.array[src + i];
			}
		}
	}
	
	//HeapSort implementation
	/*
	private static int left(int i) {
		return (i << 1) | 1;
	}
	
	private static int right(int i) {
		return (i << 1) + 2;
	}
	
	private static <E> void maintainHeap(int ptr, int i, int length, Comparator<E> c) {
		while(i < length) {
			int max = i;
			
			int left = left(i);
			if(left < length && c.compare((E)Heap.array[ptr + left], (E)Heap.array[ptr + max]) > 0) {
				max = left;
			}
			int right = right(i);
			if(right < length && c.compare((E)Heap.array[ptr + right(i)], (E)Heap.array[ptr + max]) > 0) {
				max = right;
			}
			
			if(max != i) {
				swap(ptr + max, ptr + i);
				i = max;
			} else break;
		}
	}
	
	private static <E> void buildHeap(int ptr, int length, Comparator<E> c) {
		for(int i = 0; i < (length >> 1); i++) {
			maintainHeap(ptr, i, length, c);
		}
	}
	
	/**
	 * Sorts the array starting at ptr with the specified length
	 * in ascending order.
	 *
	public static <E> void heapSort(int ptr, int length, Comparator<E> c) {
		buildHeap(ptr, length, c);
		while(length > 0) {
			length--;
			swap(ptr, ptr + length);
			maintainHeap(ptr, 0, length, c);
		}
	}
	
	/**
	 * Searches for an element, assuming that the subarray is in ascending order.
	 * @return The index of the desired object, or -1 if not found.
	 *
	public static <E> int binarySearch(int ptr, int length, E search, Comparator<E> c) {
		int i = 0;
		while(length > 0) {
			int half = length >> 1;
			int comp = c.compare(search, (E)Heap.array[ptr + i + half]);
			if(comp > 0) {
				i += half + 1;
				length -= half + 1;
			} else if(comp < 0) {
				length = half;
			} else return i;
		}
		return -1;
	}
	*/
}
