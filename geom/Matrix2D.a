package geom;

import geom.Vector2D;

/**
 * A 2x2 matrix.
 * @author XPilot
 */
public class Matrix2D {
	
	/**
	 * Matrix entries. Format: e<row><column>
	 */
	public fixed e11, e12, e21, e22;
	
	/**
	 * Creates a zero matrix.
	 */
	public Matrix2D() {
		e11 = e12 = e21 = e22 = 0;
	}
	
	/**
	 * Creates a matrix with the desired entries.
	 */
	public Matrix2D(fixed e11, fixed e12, fixed e21, fixed e22) {
		this.e11 = e11;
		this.e12 = e12;
		this.e21 = e21;
		this.e22 = e22;
	}
	
	/**
	 * Creates a matrix with the same entries as m.
	 */
	public Matrix2D(Matrix2D m) {
		e11 = m.e11;
		e12 = m.e12;
		e21 = m.e21;
		e22 = m.e22;
	}

	/**
	 * Returns a clone of this matrix.
	 */
	public Matrix2D clone() {
		return new Matrix2D(this);
	}
	
	/**
	 * Determines whether this matrix and m have the same entries.
	 */
	public bool equals(Matrix2D m) {
		return this.e11 == m.e11
			&& this.e12 == m.e12
			&& this.e21 == m.e21
			&& this.e22 == m.e22;
	}
	
	/**
	 * Sets the entries of this matrix.
	 */
	public Matrix2D setMatrix(fixed e11, fixed e12, fixed e21, fixed e22) {
		this.e11 = e11;
		this.e12 = e12;
		this.e21 = e21;
		this.e22 = e22;
		return this;
	}
	
	/**
	 * Sets this matrix to have the same entries as m.
	 * @return This matrix.
	 */
	public Matrix2D setMatrix(Matrix2D m) {
		e11 = m.e11;
		e12 = m.e12;
		e21 = m.e21;
		e22 = m.e22;
		return this;
	}
	
	/**
	 * Sets this matrix to the identity.
	 * @return This matrix.
	 */
	public Matrix2D setIdentity() {
		e11 = e22 = 1;
		e12 = e21 = 0;
		return this;
	}
	
	/**
	 * Multiplies each entry of this matrix by a.
	 */
	public Matrix2D multiply(fixed a) {
		e11 = e11 * a;
		e12 = e12 * a;
		e21 = e21 * a;
		e22 = e22 * a;
		return this;
	}
	
	/**
	 * Divides each entry of this matrix by a.
	 */
	public Matrix2D divide(fixed a) {
		e11 = e11 / a;
		e12 = e12 / a;
		e21 = e21 / a;
		e22 = e22 / a;
		return this;
	}
	
	/**
	 * Calculates and returns the determinant of this matrix.
	 */
	public fixed determinant() {
		return e11 * e22 - e12 * e21;
	}
	
	/**
	 * Calculates and returns the transpose of m.
	 */
	public static Matrix2D transpose(Matrix2D m) {
		return new Matrix2D(m.e11, m.e21, m.e12, m.e22);
	}
	
	/**
	 * Calculates the transpose of m and stores the result in result.
	 * @return result
	 */
	public static Matrix2D transpose(Matrix2D m, Matrix2D result) {
		return result.setMatrix(m.e11, m.e21, m.e12, m.e22);
	}
	
	/**
	 * Transposes this matrix.
	 * @return This matrix, after transposition.
	 */
	public Matrix2D transpose() {
		fixed temp = e12;
		e12 = e21;
		e21 = temp;
		return this;
	}
	
	/**
	 * Calculates and returns the adjugate of m.
	 */
	public static Matrix2D adjugate(Matrix2D m) {
		return new Matrix2D(m.e22, -m.e21, -m.e12, m.e11);
	}
	
	/**
	 * Calculates the adjugate of m and stores the result in result.
	 * @return result
	 */
	public static Matrix2D adjugate(Matrix2D m, Matrix2D result) {
		return result.setMatrix(m.e22, -m.e21, -m.e12, m.e11);
	}
	
	/**
	 * Adjugates this matrix.
	 * @return This matrix, after adjugation.
	 */
	public Matrix2D adjugate() {
		fixed temp = e11;
		e11 = e22;
		e22 = temp;
		e12 = -e12;
		e21 = -e21;
		return this;
	}
	
	/**
	 * Calculates and returns the inverse of m.
	 */
	public static Matrix2D inverse(Matrix2D m) {
		return adjugate(m).divide(m.determinant());
	}
	
	
	/**
	 * Calculates the inverse of m and stores the result in result.
	 * @return result
	 */
	public static Matrix2D inverse(Matrix2D m, Matrix2D result) {
		return adjugate(m, result).divide(m.determinant());
	}
	
	/**
	 * Inverses this matrix.
	 * @return This matrix, after inversing.
	 */
	public Matrix2D inverse() {
		return adjugate().divide(determinant());
	}
	
	/**
	 * Multiplies v by m and returns the result.
	 */
	public static Vector2D multiply(Matrix2D m, Vector2D v) {
		return new Vector2D(m.e11 * v.x + m.e12 * v.y, m.e21 * v.x + m.e22 * v.y);
	}
	
	/**
	 * Multiplies v by m and stores the result in result.
	 * @return result
	 */
	public static Vector2D multiply(Matrix2D m, Vector2D v, Vector2D result) {
		return result.setVector(m.e11 * v.x + m.e12 * v.y, m.e21 * v.x + m.e22 * v.y);
	}
	
	/**
	 * Multiplies v by this matrix.
	 * @return v
	 */
	public Vector2D multiply(Vector2D v) {
		return v.setVector(e11 * v.x + e12 * v.y, e21 * v.x + e22 * v.y);
	}
	
	/**
	 * Multiplies v by the transpose of m and returns the result.
	 */
	public static Vector2D multiplyTrans(Matrix2D m, Vector2D v) {
		return new Vector2D(m.e11 * v.x + m.e21 * v.y, m.e12 * v.x + m.e22 * v.y);
	}
	
	/**
	 * Multiplies v by the transpose m and stores the result in result.
	 * @return result
	 */
	public static Vector2D multiplyTrans(Matrix2D m, Vector2D v, Vector2D result) {
		return result.setVector(m.e11 * v.x + m.e21 * v.y, m.e12 * v.x + m.e22 * v.y);
	}
	
	/**
	 * Multiplies v by this matrix.
	 * @return v
	 */
	public Vector2D multiplyTrans(Vector2D v) {
		return v.setVector(e11 * v.x + e21 * v.y, e12 * v.x + e22 * v.y);
	}
	
	/**
	 * Calculates and returns the product of m1 and m2.
	 */
	public static Matrix2D multiply(Matrix2D m1, Matrix2D m2) {
		return new Matrix2D(m1.e11 * m2.e11 + m1.e12 * m2.e21,
							m1.e11 * m2.e12 + m1.e12 * m2.e22,
							m1.e21 * m2.e11 + m1.e22 * m2.e21,
							m1.e21 * m2.e12 + m1.e22 * m2.e22);
	}
	
	/**
	 * Calculates the product of m1 and m2 and stores the result in result.
	 * @return result
	 */
	public static Matrix2D multiply(Matrix2D m1, Matrix2D m2, Matrix2D result) {
		return result.setMatrix(m1.e11 * m2.e11 + m1.e12 * m2.e21,
								m1.e11 * m2.e12 + m1.e12 * m2.e22,
								m1.e21 * m2.e11 + m1.e22 * m2.e21,
								m1.e21 * m2.e12 + m1.e22 * m2.e22);
	}
	
	/**
	 * Multiplies this matrix by m (m on the left).
	 * @return This matrix.
	 */
	public Matrix2D multiply(Matrix2D m) {
		return setMatrix(m.e11 * e11 + m.e12 * e21,
						m.e11 * e12 + m.e12 * e22,
						m.e21 * e11 + m.e22 * e21,
						m.e21 * e12 + m.e22 * e22);
	}
	
	/**
	 * Creates the matrix for rotation CCW by a certain angle.
	 * @param angle The angle in radians.
	 */
	public static Matrix2D rotationMatrix(fixed angle) {
		fixed c = Cos(angle);
		fixed s = Sin(angle);
		return new Matrix2D(c, -s, s, c);
	}
	
	/**
	 * Creates the matrix for rotation CCW by a certain angle.
	 * @param angle The angle in radians.
	 * @param result Stores the matrix.
	 * @return result
	 */
	public static Matrix2D rotationMatrix(fixed angle, Matrix2D result) {
		fixed c = Cos(angle);
		fixed s = Sin(angle);
		return result.setMatrix(c, -s, s, c);
	}
	
	/**
	 * Creates the matrix for scaling by a certain factor.
	 * @param scale The scale factor.
	 */
	public static Matrix2D scaleMatrix(fixed scale) {
		return new Matrix2D(scale, 0, 0, scale);
	}
	
	/**
	 * Creates the matrix for scaling by a certain factor.
	 * @param scale The scale factor.
	 * @param result Stores the matrix.
	 * @return result
	 */
	public static Matrix2D scaleMatrix(fixed scale, Matrix2D result) {
		return result.setMatrix(scale, 0, 0, scale);
	}
	
	/**
	 * Creates the matrix for scaling in each component.
	 * @param scaleX The scale factor for the x component.
	 * @param scaleY The scale factor for the y component
	 */
	public static Matrix2D scaleMatrix(fixed scaleX, fixed scaleY) {
		return new Matrix2D(scaleX, 0, 0, scaleY);
	}
	
	/**
	 * Creates the matrix for scaling in each component.
	 * @param scaleX The scale factor for the x component.
	 * @param scaleY The scale factor for the y component
	 * @param result Stores the matrix.
	 * @return result
	 */
	public static Matrix2D scaleMatrix(fixed scaleX, fixed scaleY, Matrix2D result) {
		return result.setMatrix(scaleX, 0, 0, scaleY);
	}
	
	/**
	 * @return A string representation of this matrix.
	 */
	public string toString() {
		return "[[" + e11 + " " + e12 + "][" + e21 + " " + e22 + "]]";
	}
}
